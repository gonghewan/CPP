# C++

## 字符编码

- ASCII

  每一个二进制位（bit）有`0`和`1`两种状态，八个二进制位这被称为一个字节（byte）。一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从`00000000`到`11111111`。上个世纪60年代，美国制定了一套字符编码，ASCII 码一共规定了128个字符的编码，对英语字符与二进制位之间的关系，做了统一规定。

- 非ASCII编码

  英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。于是利用字节中闲置的最高位编入新的符号。比如，法语中的`é`的编码为130（二进制`10000010`）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。

  但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了`é`，在希伯来语编码中却代表了字母`Gimel` (`ג`)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。至于亚洲国家的文字使用的符号更多，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。

  中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。

- Unicode

  Unicode 是一种所有符号的编码，但它只是一个符号集，只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

- UTF-8

  是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8 的编码规则很简单，只有二条：

  1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

  2）对于`n`字节的符号（`n > 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

  下表总结了编码规则，字母`x`表示可用编码的位。

  > ```
  > Unicode符号范围        |        UTF-8编码方式
  > (十六进制)             |              （二进制）
  > ----------------------+---------------------------------------------
  > 0000 0000-0000 007F   | 0xxxxxxx
  > 0000 0080-0000 07FF   | 110xxxxx 10xxxxxx
  > 0000 0800-0000 FFFF   | 1110xxxx 10xxxxxx 10xxxxxx
  > 0001 0000-0010 FFFF   | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
  > ```

  跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节。前三个字节`EF BB BF`表示这是UTF-8编码。
  
  下面，还是以汉字`严`为例，演示如何实现 UTF-8 编码。
  
  ```
  严`的 Unicode 是`4E25`（`100111000100101`），根据上表，可以发现`4E25`处在第三行的范围内（`0000 0800 - 0000 FFFF`），因此`严`的 UTF-8 编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`严`的最后一个二进制位开始，依次从后向前填入格式中的`x`，多出的位补`0`。这样就得到了，`严`的 UTF-8 编码是`11100100 10111000 10100101`，转换成十六进制就是`E4B8A5
  ```

- 大端序和小端序

  Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用`FEFF`表示。这正好是两个字节，而且`FF`比`FE`大`1`。

  如果一个文本文件的头两个字节是`FE FF`，就表示该文件采用大头方式；如果头两个字节是`FF FE`，就表示该文件采用小头方式。

  ```
  **变量a**
  int a = 0x12345678
  
  **地址的高端与低端**
  0x00000001
  0x00000002
  0x00000003
  0x00000004
  从上倒下，由低到高，地址值小的为低端，地址值大的为高端。
  
  Bit-endian 如此存放(按原来顺序存储)
  0x00000001      -- 12
  0x00000002      -- 34
  0x00000003      -- 56
  0x00000004      -- 78
  
  Little-endian 如此存放(颠倒顺序储存)
  0x00000001      -- 78
  0x00000002      -- 56
  0x00000003      -- 34
  0x00000004      -- 12
  ```

## 变量

### 变量类型

- 在不声明变量类型时，小数默认为double类型。
- 整形数后加f会失效，想声明float必须是`1.f`

### 变量初始化

- 变量初始化值取决于变量类型和变量声明的位置
- built-in类型的变量在函数外声明时初始化为0，在函数内部声明时不做初始化处理，其内存存放为任意值

**在变量未被赋值之前进行copy或其他尝试利用值的行为都会引发错误**

- 自定义类型变量初始化，如果该类型并未定义构造函数则系统调用默认的构造函数`A a=A()`，如果该类型定义了构造函数`A(int aa){xxx}` 则`A a=A()`会因未遵循构造函数的格式而报错

- 定义数组时，如果没有显示提供初始化列表，则数组元素的自动化初始规则同普通变量一样：
  - 函数体外定义的内置类型数组，其元素初始为0
  - 函数体内定义的内置类型数组，其元素无初始化
  - 类类型数组无论在哪里定义，皆调用默认构造函数进行初始化，无默认构造函数则必须提供显示初始化列表
  - 如果定义数组时，仅提供了部分元素的初始列表，其剩下的数组元素，若是类类型则调用默认构造函数进行初始，若是内置类型则初始为0（不论数组定义位置）
  - 对于动态分配的数组，如果数组元素是内置类型，其元素无初始化；如果数组元素是类类型，依然调用默认构造函数进行初始化，也可以在使用跟在数组长度后面的一对空圆括号对数组元素做值初始化

### 变量定义与声明的区别

- 声明：让程序知道有这个变量，声明语句中一旦包含初始化值则extern声明失效，该声明语句即为一个定义语句

- 定义：创建实体，一个变量的定义即包含了声明

变量的声明确定了数据类型和变量名，定义会进行内存的收集分配，变量可以定义一次但可以声明多次，如在一个文件中的变量被多个文件引用时产生多个声明。

```CPP
extern int i;   //declares but does not define i
int j;  //declares and defines j
```

### 变量名

- 使用下划线的变量名不可以在后面紧接大写字符，不可以连续两个下划线，函数外定义的变量名不可用下划线为起始字符

### 引用和指针

- 引用实质上是一个常量指针，其对应的内存中存储的是被引用对象的内存地址，引用只能且必须初始化一次，使用引用只是为变量增加一个新名字，由于指针的错误难以被编译器发现，所以使用不可变的指针更加安全
- 指针可以改变（复制，再赋值），可以是未经初始化的空指针

但二者语法使用有区别

```
#include<iostream>
int main(){
        int val=1024;
        int a=1.01;
        int& ref = val;
        val=3;
        std::cout << ref<<std::endl;
        std::cout << a<<std::endl;
        std::cout << "pointer"<<std::endl;
        int *p=&val;
        std::cout<< p << "/"  << *p << std::endl;
        return 0;
}
输出：
3
1
pointer
0x7ffc9d9300a0/3

```

