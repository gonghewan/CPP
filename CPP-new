## 第二章
- 引用与指针
  - 引用，不是一个object，所以没有地址，也意味着指针是无法指向引用的
  - 指针，是一个object，其值是地址
  对于引用，c++应该是作为声明来处理，虽然在内存中仍然会为引用分配空间，用于存储“b指向a”这一信息，不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间，且取其地址时直接取到
  所指向的地址。实际在内存空间上，引用本身也占用一块内存，里面存储着所引用的变量的地址，大小与指针相同，字面上也表现为unsigned long int型。只是经过编译器处理后，访问这块内存时将直
  接转而访问其指向的内存。因此在程序中无法读取到这块内存本身。
  声明空指针的三种方式：
  int *p1 = nullptr; // equivalent to int *p1 = 0;
  int *p2 = 0; // directly initializes p2 from the literal constant 0
  // must #include cstdlib
  int *p3 = NULL; // equivalent to int *p3 = 0;
  在声明引用或定义指针时，应该将*和&与变量名置于一处：
     - int* p1, p2; // p1 is a pointer to int; p2 is an int
     - int *p1, *p2; // both p1 and p2 are pointers to int （建议）
     - int* p1; // p1 is a pointer to int
       int* p2; // p2 is a pointer to int
  int i = 42;
  int *p; // p is a pointer to int
  int *&r = p; // r is a reference to the pointer p
  r = &i; // r refers to a pointer; assigning &i to r makes p point to i
  *r = 0; // dereferencing r yields i, the object to which p points; changes i to 0
  The easiest way to understand the type of r is to read the definition right to left. The symbol closest to the name of the variable (in this case the & 
  in &r) is the one that has the most immediate effect on the variable’s type. Thus, we know that r is a reference. The rest of the declarator determines 
  the type to which r refers. The next symbol, * in this case, says that the type r refers to is a pointer type. Finally, the base type of the declaration 
  says that r is a reference to a pointer to an int.
  
  
  - const
  编译器对于const变量时常在编译的时候就将该变量替换为常数，在互相引用的几个文件中出现的同名const变量，不会混淆，每个const变量仅对当前文件可用。
  当需要在其他文件中使用本文件中定义的const变量时，需要使用extern关键字
  // file_1.cc defines and initializes a const that is accessible to other files
  extern const int bufSize = fcn();
  // file_1.h
  extern const int bufSize; // same bufSize as defined in file_1.cc
  In this program, file_1.cc defines and initializes bufSize. Because this declaration includes an initializer, it is (as usual) a definition. However, 
  because bufSize is const, we must specify extern in order for bufSize to be used in other files.
  The declaration in file_1.h is also extern. In this case, the extern signifies that bufSize is not local to this file and that its definition will 
  occur elsewhere.
  
  
- 区别指针常量和常量指针
  int errNumb = 0;
  int *const curErr = &errNumb; // curErr will always point to errNumb
  const double pi = 3.14159;
  const double *const pip = &pi; // pip is a const pointer to a const object
  top-level const: a const pointer points to const object
  low-level const: a nonconst pointer points to const object
  
  
- constexpr，编译时即确定值
  const int *p = nullptr; // p is a pointer to a const int
  constexpr int *q = nullptr; // q is a const pointer to int
  
  
- 变量类型
  需要注意如int和unsigned int之间的转换，值得一提的是，我们在定义或赋值一个负数时，如int a = -10，实际上存储的是10，“-”会作为符号来保存
  
- 别名
  - typedef
    typedef double wages; // wages is a synonym for double
    typedef wages base, *p; // base is a synonym for double, p for double*
  - using
    using SI = Sales_item; // SI is a synonym for Sales_item
- auto
  auto i = 0, *p = &i; // ok: i is int and p is a pointer to int
  auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi
## 第三章
- 拷贝初始化和直接初始化
  https://en.cppreference.com/w/cpp/language/direct_initialization
  string s5 = "hiya"; // copy initialization
  string s6("hiya"); // direct initialization
  string s7(10, 'c'); // direct initialization; s7 is cccccccccc
  - copy initialization
    当初始化函数为显式（explicit）时，拷贝初始化将失败。
  - direct initialization
- cin
  返回值是输入流本身，所以在cin << x << y << ...中不需要区分x和y的类型
- size
  string.size()返回值是string::size_type类型，可以看作是一个可以足够大的无符号数
- vector
 stl container的元素应该是可赋值的可交换位置的，所以像<const int>、<int&>之类的都不可以作为vector的元素
